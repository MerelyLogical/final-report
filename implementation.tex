\section{Implementation Plan}
% The implementation plan is a preliminary breakdown of the work that is to be
% done in the remainder of the project. You should identify a set of milestones
% and provide a realistic estimate of when each of these should be completed if
% all goes well. It should also detail fallback positions in case any stage of the
% development goes wrong. You may feel, in the early stages of your project work,
% that the times in this plan are guesses. However you will find as the project
% progresses that keeping track of and revising your initial estimates, and if
% necessary altering the proposed work, is a vital way to ensure that the project
% is finished in time. In projects with heavy implementation content you should
% document what you have already completed.


\subsection{Milestones}
The initial deliverable for the engineering side involves running a simple
program on the FPGA through the HPS with the FPGA frequency being controllable.
After this, the next critical step would be making sure the modules under test
will be the point of failure and not the testbench.
This would include some research on ways in improving the speed of feeding
inputs to the arithmetic units, and checking its outputs.
Once this could be confirmed, we can start adding a selection of different
functionalities.

\begin{enumerate}
  \item Running standard benchmarks;
  \item Running key algorithms or their components;
  \item Experiment with other power efficiency improving techniques,
        such as undervolting;
  \item Add support for configurable radix arithmetic;
  \item Allow graceful failures for the testbench in case of unintended
        behaviour for the arithmetic modules;
  \item Add an interactive UI to control the voltage and frequency at run time
        and examine the DUTâ€™s behaviour;
\end{enumerate}

Depending on the time situation, more or less items on this list may be
fulfilled.
The method of evaluation will be discussed later in the evaluation chapter.

\subsection{Timeline}
\begin{figure*}
  \centering
  \input{timeline}
  \caption{Project Timeline}
  \label{Timeline}
\end{figure*}

In order to track the progress and success of the project, the difficulties
of the deliverables need to be analysed first.
Figure \ref{Timeline} provides a visualisation of the project timeline.
Some slack is included into the plan to reduce risk and give potential for
extension.

\subsubsection{\textbf{Term Time and Examinations}}
Time available for the project varies greatly throughout the year.
The greatest factors would be the term time and the examinations.
The time needed for revision has been marked in the chart.
These times will give minimum progress to the project.

During term time, there would be coursework deadlines, which would also
negatively affect the time that could be allocated to this project.
One coursework module was selected for Autumn and three was picked for Summer.
As such, it is expected that the progress would be somewhat slower during Autumn
but significantly slower during Spring.
To make up for the time lost, a part of Christmas were used and a few weeks
from Easter will also be committed towards the project.

The list of tasks were then laid out onto the timeline.
This is done according to its expected difficulty and the expected availability
to work on these tasks.

\subsubsection{\textbf{Background Research}}
To fill in the background knowledge required to work on this project, the first
months were spent on reading textbooks and papers.
The research is to provide context and motivation to the project.
It also provided an overview of the field of research and some understanding
towards the current state-of-art.
Most importantly, it offered the necessary tools and knowledge needed for this
project to be successful.
% REVISIT: comeback to this after re-structure of Chapter 3
% Chapter 2 of this report gives a summary of this research

\subsubsection{\textbf{Learning the Tools}}
Due to the lack of experience in programming in a hybrid SoC and the lack of
knowledge in the current state-of-art digital arithmetic designs, a significant
portion of the effort was spend on researching and learning the skills
necessary to carry out the project.
This involved building a small testing system on the board.
Details regarding this testing system can be found in the Work to Date section.

\subsubsection{\textbf{Testbench Structure}}
Once comfortable with the tools, The main design of the testbench can start.
This task would be the foundation of this project, as it would provide a basis
for all following features.
A skeletal testbench should be complete and functional at the end of this
task.
This means the an operator module matching the correct specifications can
be loaded into the testbench, and compute some non-trivial tests.

\subsubsection{\textbf{Variable Frequency}}
As the project seeks to quantify the performance across a range of frequencies,
the most important feature of the system would be the ability to vary this
parameter.
This would be done by controlling the PLLs with the HPS~\cite{Altera4}.
Once implemented, some kind of test will be run to test and confirm the maximum
frequency the testbench would remain reliable.
If it does not meet the planned target, the testbench may need to be redesigned,
and this project would be under some risk.

While most of the later sections of the project can be selectively added or
removed from the scope relatively easily, this initial setup of the testbench
structure will always remain critical to any further improvements.
It is thus vital that the bare minimum system gets done early.
To ensure this happens, this task and the testbench structure will be placed in
the highest priority before its completion, and any blocking issue should be
discussed with the supervisor if it could not be resolved after reasonable
effort.

\subsubsection{\textbf{Benchmarks}}
With a promising base, more intricate tests and benchmarks can be designed.
These would aim to reflect the system's performance running meaningful compute
tasks.
The systems enveloping the arithmetic modules could be optimised for popular
algorithms to evaluate real-life obtainable speed up.
In addition to better tests, this task also aims to obtain better data from
these tests.
The minimum result required here would be numerical information on power
consumption, FPGA resources required, and the data throughput.

The last three tasks forms the core of this project.
In other words, all three tasks must be completed for a minimum functional
product.
The following tasks would be mostly considered as useful extensions.
While not as vital as the core tasks, the following tasks greatly improves the
quality of life and usability, and are thus equality critical to the success
of the final product.

\subsubsection{\textbf{Configurable Modules}}
So far, only modules of a specific I/O width and numerical representation
could be tested.
It might be interesting to explore arithmetic modules with other configurations.
To allow the testbench be used for further experiments or future projects,
it is helpful to have a configurable testbench.
Qsys components can be configured with the Hardware Component Definition
File~\cite{Altera5}.
The plan is to build the testbench as a Qsys components, then use Qsys as an
interface for configuration.

\subsubsection{\textbf{Handling Failures}}
Another improvement to the testbench is related to how it handles failures
in the module.
It would be much more insightful for the user, if a more insightful failure
message is provided in addition to just a simple failure rate.
This could include examples of failed output against expected output,
or statistical data describing the pattern of failures.
This additional logic during run-time may degrade performance of the testbench,
so it would be useful for the verbosity of this information to be configurable
by the user.

\subsubsection{\textbf{Interactive UI}}
If time allows for even greater user experience enhancements, an real-time
interactive graphical user interface could be constructed for the final
demonstration.
This would visualise the reduction of the module's precision as the user
increases the clock rate.
However, this would take significant time and effort, and this task will
be re-evaluated when the project progresses to the stage.
An time-saving yet functional alternative would be a command-line interface
with a well documented user guide.

\subsubsection{\textbf{Reports and Presentation}}
The reports and the presentation are the most visible in all deliverables of
this entire process.
As such, while not directly contributing to the progress of the project,
they are still vital to its success.
They will be written alongside with the engineering process.
At the end, around a week of time will be spent solely on completing and
polishing up the report for submission.
This should allow ample time for a well-organised report to be written.

The week after the final report will be used for the presentation.
This would involve preparing a slide deck, a demo, and a script.

\subsection{Work to Date}
% REVISIT: include the use of git somewhere

Before any engineering work is done towards the final product, a small module
was build to learn the environment.
This module should be simple yet covers enough grounds to provide as much
learning during process as possible without taking up too much actual
development time towards the product.
As the greatest unfamiliarity is with the interaction across the HPS-FPGA
bridge, a simple hardware accelerated adder was used for this training.

\subsubsection{\textbf{FPGA Side}}
Programming the FPGA to communicate with the HPS is no trivial task.
Luckily, there exist a golden system reference design~\cite{Rocket1} for
the board in use for this project.
Unfortunately, support for certain versions of Quartus are missing from
the GSRD download database, including the one used for this project, 16.0.
While the design could be opened with a different version of the software,
it would cause a series of conflicts usually related to using IP Cores that
have changed over the iterations.
To circumvent this issue cleanly, GSRD version 14.1 was downloaded and compiled
on a separate install of Quartus II 14.1.
This allowed the reference design to be studied in detail, and the sections
required for this project to be rebuilt with Quartus Prime 16.0.

From the perspective of the FPGA, The HPS exposes a three bridges for
connections~\cite{Altera6}.
As this is a relatively simple task, the lightweight bridge is used.
Module \texttt{altera\_hps} exposes the master of this bridge as
\texttt{h2f\_lw\_axi\_master}.
Next, the actual hardware adder needs to be built and integrated as a hardware
module in Qsys with a matching interface.
A simple adder can produce the result after one clock cycle.
This greatly simplifies the logic required for the Avalon slave interface.
The logic for the control and data signals are then written according to the
interface specifications~\cite{Intel3}.
Following the naming conventions for the signals allows Qsys Component Editor
to automatically detect the Avalon slave from this module at analysis.
This saves the troubles of editing the \texttt{\_hw.tcl} file.
To experiment with module configuration, the adder is designed with variable
width.

The adder is then instantiated and connected to the rest of the system with
two clicks in Qsys.
From there, Qsys can generate the HDL for the entire system, which is then
compiled to a bitstream file.
With the bitstream ready, the work now shifts to the HPS.

\subsubsection{\textbf{HPS Side}}
The HPS runs Ubuntu and a bash script has been written to load the bitstream
onto the FPGA.
Next, A program is written in Python to test the hardware design from the HPS.
The interfaces are mapped onto the physical memory, thus they can be accessed
by opening \texttt{/dev/mem}.
Checking against the specifications~\cite{Altera6}, the lightweight master is
at \texttt{0xFF20\_0000}.
Qsys allocates the memory spaces of modules relatively, so when it reports
that the adder has been placed at \texttt{0x0010\_0000}, it is physically at
\texttt{0xFF30\_0000}.
The adder is then designed to have its two inputs at \texttt{0x00} and
\texttt{0x10} and its output at \texttt{0x20}, which has been assigned by Qsys
relatively to \texttt{0xFF30\_0000}.

With the memory mapping understood, the script can be designed to closely
mirror this relative relationship between the modules using classes.
For example, this allows the adder to still define its output at \texttt{0x20}
in the adder class, and then initialised with an axi module bringing it to the
correct physical address.
This parallel between software and hardware should be helpful as the product
gets more complex.

For testing, 1000 add operations are executed separately with and without the
hardware acceleration of the FPGA.
While called hardware acceleration, it is not expected for the FPGA to have
a higher performance than the HPS in this testing case.
The CPU is reasonably efficient in calculating additions, while to calculate
on the FPGA has a large overhead cost as the data transfers across the bridge
back and forth.

% REVISIT: add test data here
