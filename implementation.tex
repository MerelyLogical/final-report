\section{Implementation Plan}
% The implementation plan is a preliminary breakdown of the work that is to be
% done in the remainder of the project. You should identify a set of milestones
% and provide a realistic estimate of when each of these should be completed if
% all goes well. It should also detail fallback positions in case any stage of the
% development goes wrong. You may feel, in the early stages of your project work,
% that the times in this plan are guesses. However you will find as the project
% progresses that keeping track of and revising your initial estimates, and if
% necessary altering the proposed work, is a vital way to ensure that the project
% is finished in time. In projects with heavy implementation content you should
% document what you have already completed.


\subsection{Milestones}
The initial deliverable for the engineering side involves running a simple
program on the FPGA through the HPS with the FPGA frequency being controllable.
After this, the next critical step would be making sure the modules under test
will be the point of failure and not the testbench.
This would include some research on ways in improving the speed of feeding
inputs to the arithmetic units, and checking its outputs.
Once this could be confirmed, we can start adding a selection of different
functionalities.

\begin{enumerate}
  \item Running standard benchmarks;
  \item Running key algorithms or their components;
  \item Experiment with other power efficiency improving techniques,
        such as undervolting;
  \item Add support for configurable radix arithmetic;
  \item Allow graceful failures for the testbench in case of unintended
        behaviour for the arithmetic modules;
  \item Add an interactive UI to control the voltage and frequency at run time
        and examine the DUTâ€™s behaviour;
\end{enumerate}

Depending on the time situation, more or less items on this list may be
fulfilled.
The method of evaluation will be discussed later in the evaluation chapter.

\subsection{Timeline}
\begin{figure*}
  \centering
  \input{timeline}
  \caption{Project Timeline}
  \label{Timeline}
\end{figure*}

In order to track the progress and success of the project, the difficulties
of the deliverables need to be analysed first.
Figure \ref{Timeline} provides a visualisation of the project timeline.

\textit{\textbf{Term Time and Examinations}} --
Time available for the project varies greatly throughout the year.
The greatest factors would be the term time and the examinations.
The time needed for revision has been marked in the chart.
These times will give minimum progress to the project.

During term time, there would be coursework deadlines, which would also
negatively affect the time that could be allocated to this project.
One coursework module was selected for Autumn and three was picked for Summer.
As such, it is expected that the progress would be somewhat slower during Autumn
but significantly slower during Spring.
To make up for the time lost, a part of Christmas were used and a few weeks
from Easter will also be committed towards the project.

The list of tasks were then laid out onto the timeline.
This is done according to its expected difficulty and the expected availability
to work on these tasks.

\textit{\textbf{Background Research}} --
To fill in the background knowledge required to work on this project, the first
months were spent on reading textbooks and papers.
The research is to provide context and motivation to the project.
It also provided an overview of the field of research and some understanding
towards the current state-of-art.
Most importantly, it offered the necessary tools and knowledge needed for this
project to be successful.
% REVISIT: comeback to this after re-structure of Chapter 3
% Chapter 2 of this report gives a summary of this research

\textit{\textbf{Learning the Tools}} --
Due to the lack of experience in programming in a hybrid SoC and the lack of
knowledge in the current state-of-art digital arithmetic designs, a significant
portion of the effort was spend on researching and learning the skills
necessary to carry out the project.
This involved building a small testing system on the board.
Details regarding this testing system can be found in the Work to Date section.

% REVISIT: split TB structure to a few more tasks as it would be the longest?
\textit{\textbf{Testbench Structure}} --
Once comfortable with the tools, The main design of the testbench can start.
This task would be the foundation of this project, as it would provide a basis
for all following features.
A skeletal testbench should be complete and functional at the end of this
task.
This means the an operator module matching the correct specifications can
be loaded into the testbench, and compute some non-trivial tests.

\textit{\textbf{Variable Frequency}} --
As the project seeks to quantify the performance across a range of frequencies,
the most important feature of the system would be the ability to vary this
parameter.
This would be done by controlling the PLLs with the HPS~\cite{Altera4}.
Once implemented, some kind of test will be run to test and confirm the maximum
frequency the testbench would remain reliable.
If it does not meet the planned target, the testbench may need to be redesigned,
and this project would be under some risk.

While most of the later sections of the project can be selectively added or
removed from the scope relatively easily, this initial setup of the testbench
structure will always remain critical to any further improvements.
It is thus vital that the bare minimum system gets done early.
To ensure this happens, this task and the testbench structure will be placed in
the highest priority before its completion, and any blocking issue should be
discussed with the supervisor if it could not be resolved after reasonable
effort.

\textit{\textbf{Benchmarks}} --
With a promising base, more intricate tests and benchmarks can be designed.
These would aim to reflect the system's performance running meaningful compute
tasks.
The systems enveloping the arithmetic modules could be optimised for popular
algorithms to evaluate real-life obtainable speed up.
In addition to better tests, this task also aims to obtain better data from
these tests.
The minimum result required here would be numerical information on power
consumption, FPGA resources required, and the data throughput.

The last three tasks forms the core of this project.
In other words, all three tasks must be completed for a minimum functional
product.
The following tasks would be mostly considered as useful extensions.
While not as vital as the core tasks, the following tasks greatly improves the
quality of life and usability, and are thus equality critical to the success
of the final product.

\textit{\textbf{Configurable Modules}} --
So far, only modules of a specific I/O width and numerical representation
could be tested.
It might be interesting to explore arithmetic modules with other configurations.
To allow the testbench be used for further experiments or future projects,
it is helpful to have a configurable testbench.
Qsys components can be configured with the Hardware Component Definition
File~\cite{Altera5}.
The plan is to build the testbench as a Qsys components, then use Qsys as an
interface for configuration.

\textit{\textbf{Handling Failures}} --
Another improvement to the testbench is related to how it handles failures
in the module.
It would be much more insightful for the user, if a more insightful failure
message is provided in addition to just a simple failure rate.
This could include examples of failed output against expected output,
or statistical data describing the pattern of failures.
This additional logic during run-time may degrade performance of the testbench,
so it would be useful for the verbosity of this information to be configurable
by the user.

\textit{\textbf{Interactive UI}} --
If time allows for even greater user experience enhancements, an real-time
interactive graphical user interface could be constructed for the final
demonstration.
This would visualise the reduction of the module's precision as the user
increases the clock rate.
However, this would take significant time and effort, and this task will
be re-evaluated when the project progresses to the stage.
An time-saving yet functional alternative would be a command-line interface
with a well documented user guide.

\textit{\textbf{Reports and Presentation}} --
The reports and the presentation are the most visible in all deliverables of
this entire process.
As such, while not directly contributing to the progress of the project,
they are still vital to its success.
They will be written alongside with the engineering process.
At the end, around a week of time will be spent solely on completing and
polishing up the report for submission.
This should allow ample time for a well-organised report to be written.

The week after the final report will be used for the presentation.
This would involve preparing a slide deck, a demo, and a script.

\subsection{Work to Date}
% REVISIT: include the use of git somewhere

% mostly ad hoc TB, lack of standards for comparison.