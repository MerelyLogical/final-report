\chapter{Introduction}

With the right number representation system, it is possible to perform arithmetic operations MSD first.
Consequently, these online arithmetic operators are attractive for hardware implementation in both serial and parallel forms.
When computing digits serially, they can be chained such that subsequent operations begin before the preceding ones complete.
Parallel implementations tend to be most sensitive to failure in their LSDs, making them more friendly to overclocking than their LSD first counterparts, for which the opposite is true.
In the past, online operators have typically been implemented in binary.
Although Radix-2 modules are the simplest to design and have the shortest cycle time per digit, they have the highest online delay and require the largest number of cycles to complete calculations~\cite{Tenca1}.
As such, the choice of binary is not absolute.

The initial goal of this project is thus to build a testbench that can investigate the operators' suitability for FPGA implementation and examine the resultant tradeoffs between performance, area and power.
However, after some time researching and working on the project, we realised that the testbench can be extended to a more general testing framework with some effort.
This makes the project much more meaningful in the long term, as researchers working on other arithmetic units can also utilise this testbench after some configuration.
The focus of the project thus shifted to delivering a customisable and extensible verification system while retaining the at-speed testing capabilities needed for the starting goal.

In this report, we will first discuss the motivations of investigating high-radix online arithmetic hardware on FPGAs in chapter 1.
Following which the design of the evaluation framework will be put forth in chapter 4, and the design process of each individual module will be examined in detail in chapter 5 and 6.
After determining the preferred designs, we will present how each module was built on the FPGA development board in chapter 7, 8 and 9.
With the implementation complete, the framework itself will be evaluated to see if it fulfilled its purposes in chapter 10.
The results of this test will be subsequently analysed in chapter 11, and the report will conclude in chapter 12 before the proposing a few ideas for further improvement of the product in chapter 13.
