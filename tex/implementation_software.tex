\chapter{Software Implementation}

\subsection{Accessing the FPGA}
The interfaces are mapped onto the physical memory, thus they can be accessed by opening \texttt{/dev/mem} with the \texttt{mmap} library in the Python test script.
The 4 bytes of binary data from the FPGA also needs to be packed or unpacked with the \texttt{struct} library, as they needs to be interpreted as unsigned long integers in little-endian.
The read and write function are defined in a class called \texttt{axi}.
The base of this function is provided to me by my supervisor.

Since the design is to abstract away direct interactions with the memory locations in the test wrapper, another class called the \texttt{wrapper} is created to serve as a collection of useful read and write functions.
Similarly, a class called \texttt{pll} is created to serve the same purpose, but for the PLL reconfiguration module.
The initial version of the \texttt{pll} class was provided to me by my supervisor, but it was then modified to provide more flexibility in frequency control.

A brief summary of the PLL configuration is as follows.
There are 3 reconfigurable stages from the input frequency $f_{in}$ to the output frequency $f_{out}$, called $M$, $N$, and $C$.
$M$ is a multiplier, and $N$, and $C$ are dividers, or in an equation,
$f_{out} = f_{in} \times \frac{M}{N \times C}$.
Each stage can be individually bypassed, and there can be multiple parallel $C$ stages in a single PLL to provide multiple frequencies outputs.

Converting from the desired divisor or multiplier to binary write data is not trivial, but it can be written into a function as all the rules are stated in the user manual~\cite{Altera7}.
After writing it in, the software repeatedly

To illustrate the abstraction, we can examine what happens when the user writes the command \texttt{reset} to reset the entire system.

First the software calls the \texttt{cleanreset} function in class \texttt{wrapper}.
This calls the a function to set the reset bit and then clears it.
It also clears the enable signal and the freeze signal.
Then it writes all zeros to all driver filter control registers, completing the wrapper side reset.

Then the software calls a function in class \texttt{pll}, which sets the PLL frequency back to the default value.


\subsection{Read-eval-print Loop}

To set up a REPL, we need to define a list of expressions that the user is allowed to give to the program. (not tcl?)
\begin{table}[H]
  \centering
  \begin{tabular}{|>{\ttfamily}p{11em}|p{\dimexpr\textwidth-18em}|}
    \hline
    \textrm{Command}   & Explanation \\
    \hline
    reset              & Resets the system and test results. \\
    version            & Prints the system version. \\
    freq <speed>       & Sets the clock speed to the specified value in MHz. Prints the actual frequency configured. \\
    mode <m|a>         & Choose between \underline{m}anual and \underline{a}uto test mode. \\
    manual <a|b> <hex> & Give input in manual mode. \\
    bitset <a|b> <hex> & Force bits to be 1 in auto mode. \\
    bitclr <a|b> <hex> & Force bits to be 0 in auto mode. \\
    run <time>         & Runs the test for specified duration in ms. Prints the results at the end of the test. \\
    exit               & Exits the REPL. \\
    \hline
  \end{tabular}
  \caption{Commands accepted in test REPL}
\end{table}
