\section{Hardware Design Choices}

\input{tex/design_randomiser}

\subsection{Driver}

The output of the driver is connected to two modules.
It feeds test input to the DUT and the monitor.

\subsubsection{Filtering Input}
% REVISIT: How am I actually going to do this?
One driver focusses on fast stress tests, The other allows handwritten tests to coexist with random tests.
They can be switched in software.

\subsubsection{Synchronised Monitor Inputs}
The driver has the responsibility in ensuring the monitor receives the test output from the DUT and the test inputs at the same time.
After going through the filtering logic, the stream of test input will not only be sent to the DUT, but also sent to a shift register before reaching the monitor.
The shift register will provide the delay required for the DUT to finish its operations.
Since the number of cycle delay from input to output should be consistent and known by the user, the length of this delay can be configured before compiling the testbench.


\subsection{Monitor}

Another concern in the system design is of the different clock domains that must exist on the FPGA.
Since it is not sensible to require the reference design to run as fast as the DUT, there needs to be two clock domains in the system.
The initial idea is to have one domain surrounds the DUT and another that supports the rest of the control logic around the DUT.
These clock frequencies can be generated with PLLs, which are provided as IP Cores in the Quartus software~\cite{Altera4}.
A clock tree will distribute them to the individual modules.
Data crossing clock domains will be fed through FIFOs to prevent loss.

The proposed structure will have the bulk of the control logic running in a separate clock domain to the DUT.
Only an interface with FIFOs will be running in synchronicity with the DUT.
Therefore, the test controls can run at a slower frequency without bottlenecking the system, allowing the DUT to be stressed further.
The problem now is to ensure the monitor can handle the stream of DUT output coming in at a higher frequency that it is running at.
As the monitor needs to calculate the correct data before it can check if the DUT output is correct, it cannot keep up with the speed of the DUT.
This report consider three alternatives.

\subsubsection{Partial Monitors}
A lightweight idea is to implement a parity checker instead of a full model inside the monitors.
For example, to check an adder, the monitor can just check if the final bit with a LUT acting as a XOR gate.

Although this is reasonably fast, it cannot be extended once the DUT is faster than a parity calculation followed by a comparison.
More critically, it provides no additional information once the DUT fails, and it has a 50\% rate of ignoring an error.
If this is to be solved by increasing the number of bits checked, the problem returns back to its initial state.
Thus this method will not be experimented.

\subsubsection{Lazy Monitors}

\begin{figure}[H]
  \centering
  \includegraphics[width=12cm]{img/LazMon}
  \caption{Structure of a Lazy Monitor}
  \label{LazMon}
\end{figure}

An more scalable alternative is to have the monitor only check a selection of data sets.
For example, if the monitor is programmed to check every third test point, statistically it will make little difference to the final result.
In case the DUT is aware of this and only produce correct outputs on every third operation, this process can be randomised too.

This method can be extended if the DUT get fast simply by skipping more checks, and it has the full information when it detects an error.
However, this method needs the extra logic in the random controller, making the monitor slightly more complex than it probably should be.

\subsubsection{Parallel Monitors}

\begin{figure}[H]
  \centering
  \includegraphics[width=15cm]{img/ParMon}
  \caption{Structure of a Parallel Monitor}
  \label{ParMon}
\end{figure}

As the test data is uniform, the monitor can be parallelised in to a number of sub-monitors.
The sub-monitors is connected to a distributor that is connected to three FIFOs.
The FIFOs are the inputs and the output of the DUT.
A round robin demultiplexer distributes the data to the sub-monitors equally.
The results from each sub-monitor are then sent to a single scoreboard.
To avoid potential hazards, the output from the sub-monitors will be buffered before processed by the scoreboard.

This does not have data dependency on a random controller, and it can fully guarantee the correctness of the DUT.
It is also scalable as more sub-monitors can be added it the DUT fills up its output buffer.
As a downside, this method takes up the most FPGA resources to implement as it scales.

Comparing across the three methods, the parallel monitors will be used for this project, as it offers the best functionalities.

\subsection{Simplified Clock Domains}
During the implementation of the parallel monitors, it is realised that picking the parallel structure has enabled a simpler way for us to realise the hardware design regarding clock domains.
So far, the assumption has been that during frequency testing, the testbench would hold on to a consistent frequency, while the frequency of the DUT is varied.
However, this causes unnecessary complications as the clock ticks of the two domains would shift in and out of phase during testing, which needs to be handled with extreme care since there is heavy data moving through the domains.

Looking back at the overall structure of the framework, the slowest block is the reference designs in the sub-monitors.
The priority of a reference design is to be functionally correct.
Since the operation it carries out can still be complex, it should have a relaxed timing requirement in order to avoid additional burdens on the designer.
This would hopefully make the reference relatively easy to produce and difficult to make mistakes on.
On the other hand, the rest of the testbench should be able to operate at the speed of the DUT, as they are relatively light in terms of the logical operations that they perform.
If a slow signal path arises in the system, it is also relatively harmless to sacrifice a few cycles in terms of latency to keep its maximum frequency high.

Therefore, instead of having a fast domain surrounding the DUT, the new design would have a slow domain surrounding the sub-monitor, while the rest of the testbench is clock at the same speed as the DUT.
The number of sub-monitors is a parametrised value, but it has to be an integer.
As such, the slow domain will always have a clock frequency that is a factor of the frequency of the rest of the testbench.
This way, they can stay in phase, which may have made the design of the monitor slightly more complicated, but vastly simplified the rest of the system.


\subsection{Scoreboard}

If the monitor detects an interesting event such as an error, it will send a message to the scoreboard.
The scoreboard has counters tracking these events, which are exposed and can be read by the HPS.

The software can run statistics to provide further insights to the user.
